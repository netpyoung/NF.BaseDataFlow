using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Emit;
using NF.Tools.DataFlow.CodeGen;
using NF.Tools.DataFlow.CodeGen.Internal;
using SqlCipher4Unity3D;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.IO;
using System.Linq;
using System.Reflection;

namespace NF.Tools.DataFlow.DataExport
{
    public class DataExporter
    {
        public static int Export(DataExporterOptions exporterOpt)
        {
            CodeGeneratorOptions codegenOpt = new CodeGeneratorOptions
            {
                InputExcelPaths = exporterOpt.InputExcelPaths,
                Namespace = "AutoGenerated.DB",
            };

            if (!CodeGenerator.TryGetWorkbookInfos(codegenOpt, out List<WorkbookInfo> workbookInfos))
            {
                return 1;
            }

            List<CodeGenerator.RenderResult> rrs = CodeGenerator.GetRenderResultsOrNull(workbookInfos, codegenOpt);
            if (rrs == null)
            {
                return 1;
            }

            List<SyntaxTree> trees = new List<SyntaxTree>(rrs.Count + 1);
            foreach (CodeGenerator.RenderResult r in rrs)
            {
                SyntaxTree syntaxTree = CSharpSyntaxTree.ParseText(r.Contents);
                trees.Add(syntaxTree);
            }
            using (Stream stream = typeof(Program).Assembly.GetManifestResourceStream("SQLite.Attributes.txt"))
            using (StreamReader reader = new StreamReader(stream))
            {
                string content = reader.ReadToEnd();
                SyntaxTree syntaxTree = CSharpSyntaxTree.ParseText(content);
                trees.Add(syntaxTree);
            }
            MetadataReference[] referenceArray = new MetadataReference[]
            {
                MetadataReference.CreateFromFile(typeof(object).Assembly.Location),
                MetadataReference.CreateFromFile(typeof(DescriptionAttribute).Assembly.Location),
                MetadataReference.CreateFromFile(Path.Combine(Path.GetDirectoryName(typeof(System.Runtime.GCSettings).GetTypeInfo().Assembly.Location), "System.Runtime.dll")),
            };
            SyntaxTree[] treeArr = trees.ToArray();
            CSharpCompilation compilation = CSharpCompilation.Create(
                "assemblyName",
                treeArr,
                referenceArray,
                new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));

            Assembly asm = null;
            using (MemoryStream dllStream = new MemoryStream())
            using (MemoryStream pdbStream = new MemoryStream())
            {
                EmitResult emitResult = compilation.Emit(dllStream, pdbStream);
                if (!emitResult.Success)
                {
                    return 1;
                }
                asm = System.Runtime.Loader.AssemblyLoadContext.Default.LoadFromStream(dllStream, pdbStream);
            }

            Type[] assemplyTypoes = asm.GetTypes();
            List<Type> types = new List<Type>(assemplyTypoes.Length);
            foreach (Type type in assemplyTypoes)
            {
                if (!type.IsClass)
                {
                    continue;
                }
                if (!type.GetCustomAttributes(inherit: false).Any(x => x.GetType().Name.StartsWith("Export")))
                {
                    continue;
                }
                types.Add(type);
            }

            ExcelLoader loader = new ExcelLoader(workbookInfos);
            using (SQLiteConnection conn = new SQLiteConnection(exporterOpt.OutputPath, exporterOpt.Password, SQLiteOpenFlags.ReadWrite | SQLiteOpenFlags.Create))
            {
                for (int i = 0; i < types.Count; ++i)
                {
                    Type type = types[i];
                    List<object> dataList = loader.GetDataListOrNull(type, type.Name);
                    if (dataList == null)
                    {
                        continue;
                    }
                    Console.WriteLine($"{i + 1}/{types.Count} {type} :  {dataList.Count}");

                    conn.DropTable(type);
                    conn.CreateTable(type);
                    conn.InsertAll(dataList, type);
                }
            }
            return 0;
        }
    }
}